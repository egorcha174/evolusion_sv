var m=Object.defineProperty;var p=(s,e,t)=>e in s?m(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var o=(s,e,t)=>p(s,typeof e!="symbol"?e+"":e,t);import{ad as h,ae as w,af as f}from"./CHWeQpjd.js";class g{constructor(e,t){o(this,"ws",null);o(this,"url");o(this,"token");o(this,"messageId",0);o(this,"subscriptions",new Map);o(this,"pendingCommands",new Map);o(this,"stateChangeCallbacks",new Set);o(this,"reconnectAttempts",0);o(this,"maxReconnectAttempts",5);o(this,"connectPromise",null);o(this,"forcedDisconnect",!1);this.url=this.formatUrl(e),this.token=t}formatUrl(e){const n=e.startsWith("https")?"wss://":"ws://";let r=e.replace(/^https?:\/\//,"").replace(/\/$/,"");return`${n}${r}/api/websocket`}async connect(){if(this.forcedDisconnect=!1,!this.isConnected())return new Promise((e,t)=>{this.connectPromise={resolve:e,reject:t};try{this.ws=new WebSocket(this.url)}catch(n){this._onError(new Event("error")),t(n);return}this.ws.onopen=this._onOpen.bind(this),this.ws.onmessage=this._onMessage.bind(this),this.ws.onerror=this._onError.bind(this),this.ws.onclose=this._onClose.bind(this)})}async disconnect(){this.forcedDisconnect=!0,this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws!==null&&this.ws.readyState===1}async getStates(){return this._sendCommand({type:"get_states"})}async subscribe(e="state_changed"){return await this._sendCommand({type:"subscribe_events",event_type:e})}unsubscribe(e){this._send({type:"unsubscribe_events",subscription:e}).catch(console.error),this.subscriptions.delete(e)}async callService(e,t,n={}){await this._sendCommand({type:"call_service",domain:e,service:t,service_data:n})}onStateChange(e){this.stateChangeCallbacks.add(e)}async _sendCommand(e){if(!this.isConnected())throw new Error("Not connected");const t=++this.messageId,n={...e,id:t};return new Promise((r,a)=>{this.pendingCommands.set(t,{resolve:r,reject:a}),this.ws.send(JSON.stringify(n)),e.type==="subscribe_events"&&this.subscriptions.set(t,d=>{(e.event_type==="state_changed"||!e.event_type)&&this.stateChangeCallbacks.forEach(u=>u(d))})})}async _send(e){if(!this.isConnected())return;const t=++this.messageId,n={...e,id:t};this.ws.send(JSON.stringify(n))}_onOpen(){console.log("WS Open")}_onMessage(e){let t;try{t=JSON.parse(e.data)}catch(n){console.error("Failed to parse WS message",n);return}switch(t.type){case"auth_required":this._sendAuth();break;case"auth_ok":this.reconnectAttempts=0,this.connectPromise&&(this.connectPromise.resolve(null),this.connectPromise=null);break;case"auth_invalid":this.connectPromise&&(this.connectPromise.reject(new Error(t.message)),this.connectPromise=null),this.disconnect();break;case"result":this._handleResult(t);break;case"event":this._handleEvent(t);break}}_sendAuth(){const e={type:"auth",access_token:this.token};this.ws.send(JSON.stringify(e))}_handleResult(e){var n;const t=this.pendingCommands.get(e.id);t&&(e.success?e.result!==void 0?t.resolve(e.result):t.resolve(e.id):t.reject(new Error(((n=e.error)==null?void 0:n.message)||"Unknown error")),this.pendingCommands.delete(e.id))}_handleEvent(e){const t=this.subscriptions.get(e.id);t&&t(e.event)}_onError(e){console.error("WS Error",e),this.connectPromise&&(this.connectPromise.reject(new Error("WebSocket connection failed")),this.connectPromise=null)}_onClose(e){console.log("WS Close",e.code,e.reason),this.connectPromise&&(this.connectPromise.reject(new Error("Connection closed during handshake")),this.connectPromise=null),this.ws=null,this.pendingCommands.forEach(t=>t.reject(new Error("Connection closed"))),this.pendingCommands.clear(),this.forcedDisconnect||this._attemptReconnect()}_attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnect attempts reached");return}this.reconnectAttempts++;const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);console.log(`Reconnecting in ${e}ms... (Attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.connect().catch(t=>console.error("Reconnect failed",t))},e)}}const c=w({isConnected:!1,isLoading:!1,error:null,entities:new Map}),v=h(c,s=>Array.from(s.entities.values()));h(c,s=>Array.from(s.entities.values()).filter(e=>e.state!=="unavailable"));let i=null;async function S(s,e){i&&await _(),c.update(t=>({...t,isLoading:!0,error:null}));try{i=new g(s,e),await i.connect();const t=await i.getStates();c.update(n=>{const r=new Map;return t.forEach(a=>{r.set(a.entity_id,l(a))}),{...n,isConnected:!0,entities:r}}),await i.subscribe("state_changed"),i.onStateChange(n=>{n.data.new_state&&y(n.data.entity_id,l(n.data.new_state))})}catch(t){if(console.error("HA Connection failed:",t),c.update(n=>({...n,isConnected:!1,error:t.message||"Connection failed"})),i){try{await i.disconnect()}catch{}i=null}}finally{c.update(t=>({...t,isLoading:!1}))}}async function _(){i&&(await i.disconnect(),i=null),c.update(s=>({...s,isConnected:!1,entities:new Map,error:null}))}function y(s,e){c.update(t=>{const n=new Map(t.entities);return n.set(s,e),{...t,entities:n}})}async function E(s){if(!i||!i.isConnected())throw new Error("Not connected to Home Assistant");const t=f(c).entities.get(s);if(!t)throw new Error(`Entity ${s} not found`);const n=s.split(".")[0];if(n==="light"||n==="switch")await i.callService(n,"toggle",{entity_id:s});else if(n==="cover")await i.callService(n,"toggle",{entity_id:s});else if(n==="input_boolean")await i.callService("input_boolean","toggle",{entity_id:s});else if(n==="lock"){const r=t.state==="locked"?"unlock":"lock";await i.callService("lock",r,{entity_id:s})}else if(n==="script")await i.callService("script","turn_on",{entity_id:s});else throw new Error(`Cannot toggle entity with domain: ${n}`)}function l(s){return{entity_id:s.entity_id,state:s.state,attributes:s.attributes,last_changed:s.last_changed,last_updated:s.last_updated,context:s.context}}export{_ as d,v as e,c as h,S as i,E as t};
