var g=Object.defineProperty;var _=(n,e,t)=>e in n?g(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var o=(n,e,t)=>_(n,typeof e!="symbol"?e+"":e,t);import{x as m,w as y,y as C}from"./CXj4HnGG.js";class b{constructor(e,t){o(this,"ws",null);o(this,"url");o(this,"token");o(this,"messageId",0);o(this,"subscriptions",new Map);o(this,"pendingCommands",new Map);o(this,"stateChangeCallbacks",new Set);o(this,"reconnectAttempts",0);o(this,"maxReconnectAttempts",5);o(this,"connectPromise",null);o(this,"forcedDisconnect",!1);this.url=this.formatUrl(e),this.token=t}formatUrl(e){const s=e.startsWith("https")?"wss://":"ws://";let c=e.replace(/^https?:\/\//,"").replace(/\/$/,"");return`${s}${c}/api/websocket`}async connect(){if(this.forcedDisconnect=!1,!this.isConnected())return new Promise((e,t)=>{this.connectPromise={resolve:e,reject:t};try{this.ws=new WebSocket(this.url)}catch(s){this._onError(new Event("error")),t(s);return}this.ws.onopen=this._onOpen.bind(this),this.ws.onmessage=this._onMessage.bind(this),this.ws.onerror=this._onError.bind(this),this.ws.onclose=this._onClose.bind(this)})}async disconnect(){this.forcedDisconnect=!0,this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws!==null&&this.ws.readyState===1}async getStates(){return this._sendCommand({type:"get_states"})}async subscribe(e="state_changed"){return await this._sendCommand({type:"subscribe_events",event_type:e})}unsubscribe(e){this._send({type:"unsubscribe_events",subscription:e}).catch(console.error),this.subscriptions.delete(e)}async callService(e,t,s={}){await this._sendCommand({type:"call_service",domain:e,service:t,service_data:s})}async ping(){const e=performance.now();return await this._sendCommand({type:"ping"}),performance.now()-e}onStateChange(e){this.stateChangeCallbacks.add(e)}async _sendCommand(e){if(!this.isConnected())throw new Error("Not connected");const t=++this.messageId,s={...e,id:t};return new Promise((c,l)=>{this.pendingCommands.set(t,{resolve:c,reject:l}),this.ws.send(JSON.stringify(s)),e.type==="subscribe_events"&&this.subscriptions.set(t,f=>{(e.event_type==="state_changed"||!e.event_type)&&this.stateChangeCallbacks.forEach(w=>w(f))})})}async _send(e){if(!this.isConnected())return;const t=++this.messageId,s={...e,id:t};this.ws.send(JSON.stringify(s))}_onOpen(){console.log("WS Open")}_onMessage(e){let t;try{t=JSON.parse(e.data)}catch(s){console.error("Failed to parse WS message",s);return}switch(t.type){case"auth_required":this._sendAuth();break;case"auth_ok":this.reconnectAttempts=0,this.connectPromise&&(this.connectPromise.resolve(null),this.connectPromise=null);break;case"auth_invalid":this.connectPromise&&(this.connectPromise.reject(new Error(t.message)),this.connectPromise=null),this.disconnect();break;case"result":this._handleResult(t);break;case"event":this._handleEvent(t);break;case"pong":this._handleResult(t);break}}_sendAuth(){const e={type:"auth",access_token:this.token};this.ws.send(JSON.stringify(e))}_handleResult(e){var s;const t=this.pendingCommands.get(e.id);t&&(e.success||e.type==="pong"?e.result!==void 0?t.resolve(e.result):t.resolve(e.id):t.reject(new Error(((s=e.error)==null?void 0:s.message)||"Unknown error")),this.pendingCommands.delete(e.id))}_handleEvent(e){const t=this.subscriptions.get(e.id);t&&t(e.event)}_onError(e){console.error("WS Error",e),this.connectPromise&&(this.connectPromise.reject(new Error("WebSocket connection failed")),this.connectPromise=null)}_onClose(e){console.log("WS Close",e.code,e.reason),this.connectPromise&&(this.connectPromise.reject(new Error("Connection closed during handshake")),this.connectPromise=null),this.ws=null,this.pendingCommands.forEach(t=>t.reject(new Error("Connection closed"))),this.pendingCommands.clear(),this.forcedDisconnect||this._attemptReconnect()}_attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnect attempts reached");return}this.reconnectAttempts++;const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);console.log(`Reconnecting in ${e}ms... (Attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.connect().catch(t=>console.error("Reconnect failed",t))},e)}}const r=y({isConnected:!1,isLoading:!1,error:null,entities:new Map,latency:void 0}),R=m(r,n=>Array.from(n.entities.values()));m(r,n=>Array.from(n.entities.values()).filter(e=>e.state!=="unavailable"));let i=null,a=null,h=new Map,d=null;function v(){r.update(n=>{const e=new Map(n.entities);return h.forEach((t,s)=>{e.set(s,t)}),{...n,entities:e}}),h.clear(),d=null}function E(n,e){h.set(n,e),d||(d=requestAnimationFrame(v))}async function x(n,e){i&&await k(),r.update(t=>({...t,isLoading:!0,error:null}));try{i=new b(n,e),await i.connect();const t=await i.getStates();r.update(s=>{const c=new Map;return t.forEach(l=>{c.set(l.entity_id,p(l))}),{...s,isConnected:!0,entities:c}}),await i.subscribe("state_changed"),i.onStateChange(s=>{s.data.new_state&&A(s.data.entity_id,p(s.data.new_state))}),S()}catch(t){if(console.error("HA Connection failed:",t),r.update(s=>({...s,isConnected:!1,error:t.message||"Connection failed"})),i){try{await i.disconnect()}catch{}i=null}}finally{r.update(t=>({...t,isLoading:!1}))}}function S(){a&&clearInterval(a),u(),a=setInterval(u,3e4)}async function u(){if(!(!i||!i.isConnected()))try{const n=await i.ping();r.update(e=>({...e,latency:Math.round(n)}))}catch(n){console.warn("Ping failed",n)}}async function k(){a&&(clearInterval(a),a=null),i&&(await i.disconnect(),i=null),r.update(n=>({...n,isConnected:!1,entities:new Map,error:null,latency:void 0}))}function A(n,e){E(n,e)}async function O(n){if(!i||!i.isConnected())throw new Error("Not connected to Home Assistant");const t=C(r).entities.get(n);if(!t)throw new Error(`Entity ${n} not found`);const s=n.split(".")[0];if(s==="light"||s==="switch")await i.callService(s,"toggle",{entity_id:n});else if(s==="cover")await i.callService(s,"toggle",{entity_id:n});else if(s==="input_boolean")await i.callService("input_boolean","toggle",{entity_id:n});else if(s==="lock"){const c=t.state==="locked"?"unlock":"lock";await i.callService("lock",c,{entity_id:n})}else if(s==="script")await i.callService("script","turn_on",{entity_id:n});else throw new Error(`Cannot toggle entity with domain: ${s}`)}function p(n){return{entity_id:n.entity_id,state:n.state,attributes:n.attributes,last_changed:n.last_changed,last_updated:n.last_updated,context:n.context}}export{k as d,R as e,r as h,x as i,O as t};
