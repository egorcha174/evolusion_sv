var L=Object.defineProperty;var O=(t,e,n)=>e in t?L(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var d=(t,e,n)=>O(t,typeof e!="symbol"?e+"":e,n);import{aC as g,aB as w,ac as R}from"./BA3XBSiu.js";import{l as N}from"./BjuM01OE.js";class U{constructor(e,n){d(this,"ws",null);d(this,"url");d(this,"token");d(this,"messageId",0);d(this,"subscriptions",new Map);d(this,"pendingCommands",new Map);d(this,"stateChangeCallbacks",new Set);d(this,"reconnectAttempts",0);d(this,"maxReconnectAttempts",5);d(this,"connectPromise",null);d(this,"forcedDisconnect",!1);this.url=this.formatUrl(e),this.token=n}formatUrl(e){const s=e.startsWith("https")?"wss://":"ws://";let i=e.replace(/^https?:\/\//,"").replace(/\/$/,"");return`${s}${i}/api/websocket`}async connect(){if(this.forcedDisconnect=!1,!this.isConnected())return new Promise((e,n)=>{this.connectPromise={resolve:e,reject:n};try{this.ws=new WebSocket(this.url)}catch(s){this._onError(new Event("error")),n(s);return}this.ws.onopen=this._onOpen.bind(this),this.ws.onmessage=this._onMessage.bind(this),this.ws.onerror=this._onError.bind(this),this.ws.onclose=this._onClose.bind(this)})}async disconnect(){this.forcedDisconnect=!0,this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws!==null&&this.ws.readyState===1}async getStates(){return this._sendCommand({type:"get_states"})}async subscribe(e="state_changed"){return await this._sendCommand({type:"subscribe_events",event_type:e})}unsubscribe(e){this._send({type:"unsubscribe_events",subscription:e}).catch(console.error),this.subscriptions.delete(e)}async callService(e,n,s={}){await this._sendCommand({type:"call_service",domain:e,service:n,service_data:s})}async ping(){const e=performance.now();return await this._sendCommand({type:"ping"}),performance.now()-e}onStateChange(e){this.stateChangeCallbacks.add(e)}async _sendCommand(e){if(!this.isConnected())throw new Error("Not connected");const n=++this.messageId,s={...e,id:n};return new Promise((i,a)=>{this.pendingCommands.set(n,{resolve:i,reject:a}),this.ws.send(JSON.stringify(s)),e.type==="subscribe_events"&&this.subscriptions.set(n,o=>{(e.event_type==="state_changed"||!e.event_type)&&this.stateChangeCallbacks.forEach(c=>c(o))})})}async _send(e){if(!this.isConnected())return;const n=++this.messageId,s={...e,id:n};this.ws.send(JSON.stringify(s))}_onOpen(){console.log("WS Open")}_onMessage(e){let n;try{n=JSON.parse(e.data)}catch(s){console.error("Failed to parse WS message",s);return}switch(n.type){case"auth_required":this._sendAuth();break;case"auth_ok":this.reconnectAttempts=0,this.connectPromise&&(this.connectPromise.resolve(null),this.connectPromise=null);break;case"auth_invalid":this.connectPromise&&(this.connectPromise.reject(new Error(n.message)),this.connectPromise=null),this.disconnect();break;case"result":this._handleResult(n);break;case"event":this._handleEvent(n);break;case"pong":this._handleResult(n);break}}_sendAuth(){const e={type:"auth",access_token:this.token};this.ws.send(JSON.stringify(e))}_handleResult(e){var s;const n=this.pendingCommands.get(e.id);n&&(e.success||e.type==="pong"?e.result!==void 0?n.resolve(e.result):n.resolve(e.id):n.reject(new Error(((s=e.error)==null?void 0:s.message)||"Unknown error")),this.pendingCommands.delete(e.id))}_handleEvent(e){const n=this.subscriptions.get(e.id);n&&n(e.event)}_onError(e){console.error("WS Error",e),this.connectPromise&&(this.connectPromise.reject(new Error("WebSocket connection failed")),this.connectPromise=null)}_onClose(e){console.log("WS Close",e.code,e.reason),this.connectPromise&&(this.connectPromise.reject(new Error("Connection closed during handshake")),this.connectPromise=null),this.ws=null,this.pendingCommands.forEach(n=>n.reject(new Error("Connection closed"))),this.pendingCommands.clear(),this.forcedDisconnect||this._attemptReconnect()}_attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnect attempts reached");return}this.reconnectAttempts++;const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);console.log(`Reconnecting in ${e}ms... (Attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.connect().catch(n=>console.error("Reconnect failed",n))},e)}}const h=w({isConnected:!1,isLoading:!1,error:null,entities:new Map,problemEntities:new Set,latency:void 0});g(h,t=>Array.from(t.entities.values()));let r=null,p=null,y=new Map,v=null;function W(){h.update(t=>{const e=new Map(t.entities),n=new Set(t.problemEntities);return y.forEach((s,i)=>{e.set(i,s),s.state==="unavailable"||s.state==="unknown"?n.add(i):n.delete(i)}),{...t,entities:e,problemEntities:n}}),y.clear(),v=null}function x(t,e){y.set(t,e),v||(v=requestAnimationFrame(W))}async function K(t,e){r&&await F(),h.update(n=>({...n,isLoading:!0,error:null}));try{r=new U(t,e),await r.connect();const n=await r.getStates();h.update(s=>{const i=new Map,a=new Set;return n.forEach(o=>{const c=A(o);i.set(o.entity_id,c),(c.state==="unavailable"||c.state==="unknown")&&a.add(o.entity_id)}),{...s,isConnected:!0,entities:i,problemEntities:a}}),await r.subscribe("state_changed"),r.onStateChange(s=>{s.data.new_state&&j(s.data.entity_id,A(s.data.new_state))}),B()}catch(n){if(console.error("HA Connection failed:",n),h.update(s=>({...s,isConnected:!1,error:n.message||"Connection failed"})),r){try{await r.disconnect()}catch{}r=null}}finally{h.update(n=>({...n,isLoading:!1}))}}function B(){p&&clearInterval(p),S(),p=setInterval(S,3e4)}async function S(){if(!(!r||!r.isConnected()))try{const t=await r.ping();h.update(e=>({...e,latency:Math.round(t)}))}catch(t){console.warn("Ping failed",t)}}async function F(){p&&(clearInterval(p),p=null),r&&(await r.disconnect(),r=null),h.update(t=>({...t,isConnected:!1,entities:new Map,problemEntities:new Set,error:null,latency:void 0}))}function j(t,e){x(t,e)}async function Y(t){if(!r||!r.isConnected())throw new Error("Not connected to Home Assistant");const n=R(h).entities.get(t);if(!n)throw new Error(`Entity ${t} not found`);const s=t.split(".")[0];if(s==="light"||s==="switch")await r.callService(s,"toggle",{entity_id:t});else if(s==="cover")await r.callService(s,"toggle",{entity_id:t});else if(s==="input_boolean")await r.callService("input_boolean","toggle",{entity_id:t});else if(s==="lock"){const i=n.state==="locked"?"unlock":"lock";await r.callService("lock",i,{entity_id:t})}else if(s==="script")await r.callService("script","turn_on",{entity_id:t});else throw new Error(`Cannot toggle entity with domain: ${s}`)}function A(t){return{entity_id:t.entity_id,state:t.state,attributes:t.attributes,last_changed:t.last_changed,last_updated:t.last_updated,context:t.context}}const C=[{id:"home",title:"Dashboard",icon:"mdi:view-dashboard"},{id:"living_room",title:"Living Room",icon:"mdi:sofa"},{id:"bedroom",title:"Bedroom",icon:"mdi:bed"}];function H(){const{subscribe:t,set:e,update:n}=w(C);return{subscribe:t,addTab:()=>n(s=>{const i=`tab_${Date.now()}`;return[...s,{id:i,title:`New Tab ${s.length+1}`}]}),removeTab:s=>n(i=>i.filter(a=>a.id!==s)),reset:()=>e(C)}}const Q=H(),P=w(C[0].id),J=w(!1);function X(t){P.set(t)}function Z(){J.update(t=>!t)}function _(t){return t.split(".")[0]}function $(t){return["light","switch","cover","lock","input_boolean","automation","script"].includes(t)}g(h,t=>{const e=[];for(const n of t.problemEntities){const s=t.entities.get(n);s&&e.push(s)}return e});const M=w(280),T="evolusion.sidebar.width";function ee(){try{const t=localStorage.getItem(T);if(t){const e=parseInt(t,10);!isNaN(e)&&e>=200&&e<=500&&M.set(e)}}catch(t){console.error("Failed to load UI state",t)}}function te(t){try{localStorage.setItem(T,t.toString()),M.set(t)}catch(e){console.error("Failed to save UI state",e)}}const V={filters:{search:"",domain:void 0,showOnlyProblem:!1},sort:{key:"name",direction:"asc"}},D=w(V);function E(t,e,n,s){let i=t;if(e.showOnlyProblem&&(i=i.filter(a=>s.has(a.entity_id))),e.domain&&(i=i.filter(a=>_(a.entity_id)===e.domain)),e.search){const a=e.search.toLowerCase();i=i.filter(o=>{var c;return o.entity_id.includes(a)||((c=o.attributes.friendly_name)==null?void 0:c.toLowerCase().includes(a))})}return i.sort((a,o)=>{let c,u;switch(n.key){case"domain":c=_(a.entity_id),u=_(o.entity_id);break;case"state":c=a.state,u=o.state;break;case"last_changed":c=a.last_changed||"",u=o.last_changed||"";break;case"name":default:c=a.attributes.friendly_name||a.entity_id,u=o.attributes.friendly_name||o.entity_id;break}return c<u?n.direction==="asc"?-1:1:c>u?n.direction==="asc"?1:-1:0}),i}const ne=g([h,D],([t,e])=>E(Array.from(t.entities.values()),e.filters,e.sort,t.problemEntities)),se=g([h,D,P,N],([t,e,n,s])=>{const i=Array.from(t.entities.values()),a=new Set(["light","switch","climate","media_player","cover","lock","script","input_boolean"]);let o=i.filter(f=>{const m=_(f.entity_id);return a.has(m)});if(n!=="home"){const m=n.split("_").map(l=>l.toLowerCase());o=o.filter(l=>{const b=(l.attributes.friendly_name||"").toLowerCase(),I=l.entity_id.toLowerCase();return m.some(k=>b.includes(k)||I.includes(k))})}(e.filters.search||e.filters.domain)&&(o=E(o,e.filters,e.sort,t.problemEntities));let c=[];const u=n==="home"&&!e.filters.search&&!e.filters.domain;if(u&&s.cardOrder.length>0){const f=o.map(l=>[l.entity_id,l]),m=new Map(f);for(const l of s.cardOrder)if(m.has(l)){const b=m.get(l);c.push({...b,id:l}),m.delete(l)}for(const l of m.values())c.push({...l,id:l.entity_id})}else u||(o=E(o,{...e.filters,search:"",domain:void 0},e.sort,t.problemEntities)),c=o.map(f=>({...f,id:f.entity_id}));return c});export{se as a,P as b,te as c,M as d,_ as e,Q as f,J as g,h,$ as i,Z as j,X as k,ee as l,K as m,F as n,ne as s,Y as t,D as u};
