var ae=Object.defineProperty;var ce=(n,e,s)=>e in n?ae(n,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[e]=s;var m=(n,e,s)=>ce(n,typeof e!="symbol"?e+"":e,s);import{G as y,F as A,aU as O}from"./DrE23S9z.js";function q(){if(typeof crypto<"u"&&crypto.randomUUID)try{return crypto.randomUUID()}catch{}return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(n){const e=Math.random()*16|0;return(n==="x"?e:e&3|8).toString(16)})}function Oe(){return{id:q(),name:"New Template",style:{backgroundType:"color",backgroundColor:"#ffffff",shadow:"sm",opacity:1,padding:16},elements:[]}}const le=1e5,de=16,ue=256;function z(n){return new TextEncoder().encode(n)}function Z(n){let e="";const s=n.byteLength;for(let t=0;t<s;t++)e+=String.fromCharCode(n[t]);return btoa(e)}function Q(n){const e=atob(n),s=new Uint8Array(e.length);for(let t=0;t<e.length;t++)s[t]=e.charCodeAt(t);return s}function V(){const n=window.crypto.getRandomValues(new Uint8Array(de));return Z(n)}async function C(n,e){const s=Q(e),t=await window.crypto.subtle.importKey("raw",z(n),{name:"PBKDF2"},!1,["deriveKey"]);return window.crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:le,hash:"SHA-256"},t,{name:"AES-GCM",length:ue},!1,["encrypt","decrypt"])}async function x(n,e){const s=window.crypto.getRandomValues(new Uint8Array(12)),t=z(n),o=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},e,t),r=new Uint8Array(s.length+o.byteLength);return r.set(s),r.set(new Uint8Array(o),s.length),Z(r)}async function I(n,e){const s=Q(n),t=s.slice(0,12),o=s.slice(12),r=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:t},e,o);return new TextDecoder().decode(r)}async function G(n){return x("valid-pin-verifier",n)}async function R(n,e){try{return await I(n,e)==="valid-pin-verifier"}catch{return!1}}const E="auth_salt",k="auth_verifier",w="auth_auto_pin";function fe(){const{subscribe:n,set:e,update:s}=y({state:"loading",key:null,error:null,isAutoLogin:!1});return{subscribe:n,init:async()=>{try{const t=localStorage.getItem(E),o=localStorage.getItem(k),r=localStorage.getItem(w);if(t&&o){if(r)try{const a=atob(r),c=await C(a,t);if(await R(o,c)){s(h=>({...h,state:"active",key:c,isAutoLogin:!0}));return}else console.warn("Auto-login PIN invalid, removing."),localStorage.removeItem(w)}catch(a){console.error("Auto-login failed",a),localStorage.removeItem(w)}const i=!!localStorage.getItem(w);s(a=>({...a,state:"locked",isAutoLogin:i}))}else s(i=>({...i,state:"setup",isAutoLogin:!1}))}catch(t){console.error("Critical error during session init:",t),s(o=>({...o,state:"setup",error:"Initialization failed"}))}},verifyPin:async t=>{const o=localStorage.getItem(E),r=localStorage.getItem(k);if(!o||!r)return!1;try{const i=await C(t,o);return await R(r,i)}catch(i){return console.error("Verify PIN failed",i),!1}},unlock:async t=>{s(i=>({...i,error:null}));const o=localStorage.getItem(E),r=localStorage.getItem(k);if(!o||!r)return s(i=>({...i,state:"setup"})),!1;try{const i=await C(t,o);if(await R(r,i)){const c=!!localStorage.getItem(w);return s(l=>({...l,state:"active",key:i,isAutoLogin:c})),!0}else return s(c=>({...c,error:"Invalid PIN"})),!1}catch(i){return console.error(i),s(a=>({...a,error:"Unlock failed"})),!1}},setup:async t=>{try{const o=V(),r=await C(t,o),i=await G(r);return localStorage.setItem(E,o),localStorage.setItem(k,i),localStorage.removeItem(w),localStorage.removeItem("app_server_config_encrypted"),s(a=>({...a,state:"active",key:r,error:null,isAutoLogin:!1})),!0}catch(o){return console.error(o),s(r=>({...r,error:"Setup failed"})),!1}},changePin:async t=>{try{const o=V(),r=await C(t,o),i=await G(r);return localStorage.setItem(E,o),localStorage.setItem(k,i),localStorage.getItem(w)&&localStorage.setItem(w,btoa(t)),s(a=>({...a,key:r,error:null})),!0}catch(o){return console.error(o),s(r=>({...r,error:"Change PIN failed"})),!1}},lock:()=>{s(t=>({...t,state:"locked",key:null}))},enableAutoLogin:t=>{localStorage.setItem(w,btoa(t)),s(o=>({...o,isAutoLogin:!0}))},disableAutoLogin:()=>{localStorage.removeItem(w),s(t=>({...t,isAutoLogin:!1}))}}}const X=fe(),T=y({activeServer:null,savedServers:[]}),K=y({cardOrder:[],timestamp:Date.now()}),j="app_server_config_encrypted",$="app_servers_list_encrypted",ee="dashboard_layout_encrypted";function S(){const n=A(X);if(!n.key)throw new Error("Session is locked. Key not available.");return n.key}async function xe(){try{const n=localStorage.getItem(j);if(n){const e=S(),s=await I(n,e),t=JSON.parse(s);t.id||(t.id=q()),t&&t.url&&t.token&&T.update(o=>({...o,activeServer:t}))}}catch(n){console.error("Failed to load server config (decryption failed or locked)",n)}}async function Ie(){try{let n=[];const e=localStorage.getItem($);if(e){const s=S(),t=await I(e,s);n=JSON.parse(t)}T.update(s=>({...s,savedServers:n}))}catch(n){console.error("Failed to load saved servers",n)}}async function Te(n){try{const e=S(),s=JSON.stringify(n),t=await x(s,e);localStorage.setItem($,t),T.update(o=>({...o,savedServers:n}))}catch(e){console.error("Failed to save servers list",e)}}async function Pe(n){try{const e=S(),s=JSON.stringify(n),t=await x(s,e);localStorage.setItem(j,t),T.update(o=>({...o,activeServer:n}))}catch(e){throw console.error("Failed to save server config",e),e}}function Le(){try{localStorage.removeItem(j),T.update(n=>({...n,activeServer:null}))}catch(n){console.error("Failed to clear server config",n)}}async function De(){try{const n=localStorage.getItem(ee);if(n){const e=S(),s=await I(n,e),t=JSON.parse(s);K.set(t)}}catch(n){console.error("Failed to load layout:",n)}}async function Me(n){const e={cardOrder:n,timestamp:Date.now()};try{const s=S(),t=JSON.stringify(e),o=await x(t,s);localStorage.setItem(ee,o),K.set(e)}catch(s){console.error("Failed to save layout:",s)}}const J="evolusion_dashboard_v2_encrypted",te=8,ne=6;function B(){const n=A(X);if(!n.key)throw new Error("Session is locked. Key not available.");return n.key}function L(n,e){return{id:n,title:e,icon:"mdi:view-dashboard",gridColumns:te,gridRows:ne,cards:[],provisioned:!1}}const Y={version:3,tabOrder:["welcome"],tabs:{welcome:{id:"welcome",title:"Welcome",icon:"mdi:hand-wave",gridColumns:te,gridRows:ne,cards:[],provisioned:!0}},templates:{}};function he(){const{subscribe:n,set:e,update:s}=y(Y);return{subscribe:n,set:e,async init(){try{const t=localStorage.getItem(J);if(t){const o=B(),r=await I(t,o),i=JSON.parse(r);!i.tabOrder&&i.tabs&&(i.tabOrder=Object.keys(i.tabs)),i.tabs&&Object.values(i.tabs).forEach(a=>{a.title||(a.title=a.id)}),i.templates||(i.templates={}),e({...Y,...i})}}catch(t){console.error("Failed to load dashboard config",t)}},async save(){const t=A({subscribe:n});try{const o=B(),r=JSON.stringify(t),i=await x(r,o);localStorage.setItem(J,i)}catch(o){console.error("Failed to save dashboard config",o)}},ensureTabConfig(t){s(o=>{if(!o.tabs[t]){const r=L(t,"New Tab");return{...o,tabOrder:[...o.tabOrder,t],tabs:{...o.tabs,[t]:r}}}return o})},addTab(t){const o=`tab_${Date.now()}`;return s(r=>({...r,tabOrder:[...r.tabOrder,o],tabs:{...r.tabs,[o]:L(o,t)}})),this.save(),o},deleteTab(t){s(o=>{if(o.tabOrder.length<=1)return o;const r={...o.tabs};return delete r[t],{...o,tabOrder:o.tabOrder.filter(i=>i!==t),tabs:r}}),this.save()},renameTab(t,o){s(r=>r.tabs[t]?{...r,tabs:{...r.tabs,[t]:{...r.tabs[t],title:o}}}:r),this.save()},clearTab(t){s(o=>o.tabs[t]?{...o,tabs:{...o.tabs,[t]:{...o.tabs[t],cards:[],provisioned:!0}}}:o),this.save()},updateTabSettings(t,o,r){s(i=>{const a=i.tabs[t]||L(t,t),c={...i.tabs,[t]:{...a,gridColumns:o,gridRows:r}};return{...i,tabs:c}}),this.save()},saveTemplate(t){s(o=>({...o,templates:{...o.templates,[t.id]:t}})),this.save()},deleteTemplate(t){s(o=>{const r={...o.templates};return delete r[t],{...o,templates:r}}),this.save()},replaceTabCards(t,o){s(r=>{const i=r.tabs[t];return i?{...r,tabs:{...r.tabs,[t]:{...i,cards:o,provisioned:!0}}}:r}),this.save()},updateCardPosition(t,o,r){s(i=>{const a=i.tabs[t];if(!a)return i;const c=a.cards.map(l=>l.id===o?{...l,position:r}:l);return{...i,tabs:{...i.tabs,[t]:{...a,cards:c,provisioned:!0}}}}),this.save()},assignTemplateToCard(t,o,r){s(i=>{const a=i.tabs[t];if(!a)return i;const c=a.cards.map(l=>l.id===o?{...l,templateId:r}:l);return{...i,tabs:{...i.tabs,[t]:{...a,cards:c,provisioned:!0}}}}),this.save()},addCard(t,o){s(r=>{const i=r.tabs[t];if(!i)return r;let a=0,c=0,l=!1;const h=new Set;i.cards.forEach(d=>{for(let b=0;b<d.position.w;b++)for(let P=0;P<d.position.h;P++)h.add(`${d.position.x+b},${d.position.y+P}`)});const u=i.gridColumns,g=i.gridRows;for(let d=0;d<g;d++){for(let b=0;b<u;b++)if(!h.has(`${b},${d}`)){a=b,c=d,l=!0;break}if(l)break}l||(a=0,c=g);const v={id:`card_${Date.now()}`,entityId:o,position:{x:a,y:c,w:1,h:1}};return{...r,tabs:{...r.tabs,[t]:{...i,cards:[...i.cards,v],provisioned:!0}}}}),this.save()},deleteCard(t,o){s(r=>{const i=r.tabs[t];return i?{...r,tabs:{...r.tabs,[t]:{...i,cards:i.cards.filter(a=>a.id!==o),provisioned:!0}}}:r}),this.save()},syncEntitiesToGrid(t,o){s(r=>{const i=r.tabs[t]||L(t,t);if(i.provisioned)return r;const a=new Map(i.cards.map(d=>[d.entityId,d])),c=[];let l=0,h=0;const u=i.gridColumns;let g=0;i.cards.forEach(d=>{c.push(d),g=Math.max(g,d.position.y+d.position.h)}),c.length>0&&(h=Math.ceil(g));let v=0;return o.forEach(d=>{a.has(d.entity_id)||(l+1>u&&(l=0,h++),c.push({id:d.entity_id,entityId:d.entity_id,position:{x:l,y:h,w:1,h:1}}),l+=1,v++)}),v>0||!i.provisioned?{...r,tabs:{...r.tabs,[t]:{...i,cards:c,provisioned:!0}}}:r})}}}const se=he();class me{constructor(e,s){m(this,"ws",null);m(this,"url");m(this,"token");m(this,"messageId",0);m(this,"subscriptions",new Map);m(this,"pendingCommands",new Map);m(this,"stateChangeCallbacks",new Set);m(this,"reconnectAttempts",0);m(this,"maxReconnectAttempts",5);m(this,"connectPromise",null);m(this,"forcedDisconnect",!1);this.url=this.formatUrl(e),this.token=s}formatUrl(e){const t=e.startsWith("https")?"wss://":"ws://";let o=e.replace(/^https?:\/\//,"").replace(/\/$/,"");return`${t}${o}/api/websocket`}async connect(e){if(this.forcedDisconnect=!1,this.isConnected())return;if(this.connectPromise)return this.connectPromise.promise;this.reconnectAttempts=0;let s,t;const o=new Promise((r,i)=>{s=r,t=i});return this.connectPromise={resolve:s,reject:t,promise:o},e&&e.addEventListener("abort",()=>{this.connectPromise&&(this.connectPromise.reject(new Error("Connection aborted")),this.connectPromise=null),this.disconnect()}),this._createSocket(),o}_createSocket(){try{this.ws=new WebSocket(this.url),this.ws.onopen=this._onOpen.bind(this),this.ws.onmessage=this._onMessage.bind(this),this.ws.onerror=this._onError.bind(this),this.ws.onclose=this._onClose.bind(this)}catch(e){this._handleConnectionFailure(e)}}async disconnect(){this.forcedDisconnect=!0,this.ws&&(this.ws.close(),this.ws=null),this.connectPromise&&(this.connectPromise.reject(new Error("Disconnected by user")),this.connectPromise=null)}isConnected(){return this.ws!==null&&this.ws.readyState===1}async getStates(){return this._sendCommand({type:"get_states"})}async subscribe(e="state_changed"){return await this._sendCommand({type:"subscribe_events",event_type:e})}unsubscribe(e){this._send({type:"unsubscribe_events",subscription:e}).catch(console.error),this.subscriptions.delete(e)}async callService(e,s,t={}){await this._sendCommand({type:"call_service",domain:e,service:s,service_data:t})}async ping(){const e=performance.now();return await this._sendCommand({type:"ping"}),performance.now()-e}onStateChange(e){this.stateChangeCallbacks.add(e)}async _sendCommand(e){if(!this.isConnected())throw new Error("Not connected");const s=++this.messageId,t={...e,id:s};return new Promise((o,r)=>{this.pendingCommands.set(s,{resolve:o,reject:r}),this.ws.send(JSON.stringify(t)),e.type==="subscribe_events"&&this.subscriptions.set(s,i=>{(e.event_type==="state_changed"||!e.event_type)&&this.stateChangeCallbacks.forEach(a=>a(i))})})}async _send(e){if(!this.isConnected())return;const s=++this.messageId,t={...e,id:s};this.ws.send(JSON.stringify(t))}_onOpen(){console.log("WS Open")}_onMessage(e){let s;try{s=JSON.parse(e.data)}catch(t){console.error("Failed to parse WS message",t);return}switch(s.type){case"auth_required":this._sendAuth();break;case"auth_ok":this.reconnectAttempts=0,this.connectPromise&&(this.connectPromise.resolve(null),this.connectPromise=null);break;case"auth_invalid":this.connectPromise&&(this.connectPromise.reject(new Error(s.message)),this.connectPromise=null),this.disconnect();break;case"result":this._handleResult(s);break;case"event":this._handleEvent(s);break;case"pong":this._handleResult(s);break}}_sendAuth(){const e={type:"auth",access_token:this.token};this.ws.send(JSON.stringify(e))}_handleResult(e){var t;const s=this.pendingCommands.get(e.id);s&&(e.success||e.type==="pong"?e.result!==void 0?s.resolve(e.result):s.resolve(e.id):s.reject(new Error(((t=e.error)==null?void 0:t.message)||"Unknown error")),this.pendingCommands.delete(e.id))}_handleEvent(e){const s=this.subscriptions.get(e.id);s&&s(e.event)}_onError(e){console.error("WS Error",e)}_onClose(e){console.log("WS Close",e.code,e.reason),this.ws=null,this.pendingCommands.forEach(s=>s.reject(new Error("Connection closed"))),this.pendingCommands.clear(),this.forcedDisconnect?this.connectPromise&&(this.connectPromise.reject(new Error("Connection closed")),this.connectPromise=null):this._attemptReconnect()}_handleConnectionFailure(e){console.error("Connection failure:",e),this.forcedDisconnect||this._attemptReconnect()}_attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnect attempts reached"),this.connectPromise&&(this.connectPromise.reject(new Error("Max reconnect attempts reached")),this.connectPromise=null);return}this.reconnectAttempts++;const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);console.log(`Reconnecting in ${e}ms... (Attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.forcedDisconnect||this._createSocket()},e)}}const p=y({isConnected:!1,isLoading:!1,error:null,entities:new Map,problemEntities:new Set,latency:void 0});O(p,n=>Array.from(n.entities.values()));let f=null,_=null,F=new Map,N=null;function pe(){p.update(n=>{const e=new Map(n.entities),s=new Set(n.problemEntities);return F.forEach((t,o)=>{e.set(o,t),t.state==="unavailable"||t.state==="unknown"?s.add(o):s.delete(o)}),{...n,entities:e,problemEntities:s}}),F.clear(),N=null}function ye(n,e){F.set(n,e),N||(N=requestAnimationFrame(pe))}async function Re(n,e){f&&await we(),p.update(s=>({...s,isLoading:!0,error:null}));try{f=new me(n,e),await f.connect();const s=await f.getStates();p.update(t=>{const o=new Map,r=new Set;return s.forEach(i=>{const a=H(i);o.set(i.entity_id,a),(a.state==="unavailable"||a.state==="unknown")&&r.add(i.entity_id)}),{...t,isConnected:!0,entities:o,problemEntities:r}}),await f.subscribe("state_changed"),f.onStateChange(t=>{t.data.new_state&&be(t.data.entity_id,H(t.data.new_state))}),ge()}catch(s){if(console.error("HA Connection failed:",s),p.update(t=>({...t,isConnected:!1,error:s.message||"Connection failed"})),f){try{await f.disconnect()}catch{}f=null}}finally{p.update(s=>({...s,isLoading:!1}))}}function ge(){_&&clearInterval(_),W(),_=setInterval(W,3e4)}async function W(){if(!(!f||!f.isConnected()))try{const n=await f.ping();p.update(e=>({...e,latency:Math.round(n)}))}catch(n){console.warn("Ping failed",n)}}async function we(){_&&(clearInterval(_),_=null),f&&(await f.disconnect(),f=null),p.update(n=>({...n,isConnected:!1,entities:new Map,problemEntities:new Set,error:null,latency:void 0}))}function be(n,e){ye(n,e)}const ve={light:(n,e)=>n.callService("light","toggle",{entity_id:e.entity_id}),switch:(n,e)=>n.callService("switch","toggle",{entity_id:e.entity_id}),cover:(n,e)=>n.callService("cover","toggle",{entity_id:e.entity_id}),input_boolean:(n,e)=>n.callService("input_boolean","toggle",{entity_id:e.entity_id}),lock:(n,e)=>{const s=e.state==="locked"?"unlock":"lock";return n.callService("lock",s,{entity_id:e.entity_id})},script:(n,e)=>n.callService("script","turn_on",{entity_id:e.entity_id}),automation:(n,e)=>n.callService("automation","trigger",{entity_id:e.entity_id})};async function Fe(n){if(!f||!f.isConnected())throw new Error("Not connected to Home Assistant");const s=A(p).entities.get(n);if(!s)throw new Error(`Entity ${n} not found`);const t=n.split(".")[0],o=ve[t];if(o)await o(f,s);else throw new Error(`Cannot toggle entity with domain: ${t}`)}function H(n){return{entity_id:n.entity_id,state:n.state,attributes:n.attributes,last_changed:n.last_changed,last_updated:n.last_updated,context:n.context}}const Ne=O(se,n=>{const e=n.tabOrder||[],s=n.tabs||{};return e.map(t=>s[t]).filter(Boolean).map(t=>({id:t.id,title:t.title||t.id,icon:t.icon}))}),M=y("home"),_e=y(!1);se.subscribe(n=>{const e=A(M);n.tabOrder&&n.tabOrder.length>0&&(n.tabOrder.includes(e)||M.set(n.tabOrder[0]))});function Ue(n){M.set(n)}function Ke(){_e.update(n=>!n)}function D(n){return n.split(".")[0]}function je(n){return["light","switch","cover","lock","input_boolean","automation","script"].includes(n)}O(p,n=>{const e=[];for(const s of n.problemEntities){const t=n.entities.get(s);t&&e.push(t)}return e});const oe=y(280),re="evolusion.sidebar.width";function Ve(){try{const n=localStorage.getItem(re);if(n){const e=parseInt(n,10);!isNaN(e)&&e>=200&&e<=500&&oe.set(e)}}catch(n){console.error("Failed to load UI state",n)}}function Ge(n){try{localStorage.setItem(re,n.toString()),oe.set(n)}catch(e){console.error("Failed to save UI state",e)}}const Se=y(!1),Ce=y(!1),Je=y(!1);function Be(){Se.update(n=>!n)}function Ye(){Ce.update(n=>!n)}const Ee={filters:{search:"",domain:void 0,showOnlyProblem:!1},sort:{key:"name",direction:"asc"}},ie=y(Ee);function U(n,e,s,t){let o=n;if(e.showOnlyProblem&&(o=o.filter(r=>t.has(r.entity_id))),e.domain&&(o=o.filter(r=>D(r.entity_id)===e.domain)),e.search){const r=e.search.toLowerCase();o=o.filter(i=>{var a;return i.entity_id.includes(r)||((a=i.attributes.friendly_name)==null?void 0:a.toLowerCase().includes(r))})}return o.sort((r,i)=>{let a,c;switch(s.key){case"domain":a=D(r.entity_id),c=D(i.entity_id);break;case"state":a=r.state,c=i.state;break;case"last_changed":a=r.last_changed||"",c=i.last_changed||"";break;case"name":default:a=r.attributes.friendly_name||r.entity_id,c=i.attributes.friendly_name||i.entity_id;break}return a<c?s.direction==="asc"?-1:1:a>c?s.direction==="asc"?1:-1:0}),o}const We=O([p,ie],([n,e])=>U(Array.from(n.entities.values()),e.filters,e.sort,n.problemEntities)),He=O([p,ie,M,K],([n,e,s,t])=>{const o=Array.from(n.entities.values()),r=new Set(["light","switch","climate","media_player","cover","lock","script","input_boolean"]);let i=o.filter(l=>{const h=D(l.entity_id);return r.has(h)});if(s!=="home"){const h=s.split("_").map(u=>u.toLowerCase());i=i.filter(u=>{const g=(u.attributes.friendly_name||"").toLowerCase(),v=u.entity_id.toLowerCase();return h.some(d=>g.includes(d)||v.includes(d))})}(e.filters.search||e.filters.domain)&&(i=U(i,e.filters,e.sort,n.problemEntities));let a=[];const c=s==="home"&&!e.filters.search&&!e.filters.domain;if(c&&t.cardOrder.length>0){const l=i.map(u=>[u.entity_id,u]),h=new Map(l);for(const u of t.cardOrder)if(h.has(u)){const g=h.get(u);a.push({...g,id:u}),h.delete(u)}for(const u of h.values())a.push({...u,id:u.entity_id})}else c||(i=U(i,{...e.filters,search:"",domain:void 0},e.sort,n.problemEntities)),a=i.map(l=>({...l,id:l.entity_id}));return a});export{X as A,Me as B,K as C,Je as D,Ce as E,xe as F,Ie as G,De as H,Re as I,Fe as a,Ne as b,_e as c,se as d,D as e,M as f,Ye as g,p as h,je as i,He as j,T as k,Ve as l,oe as m,Se as n,Ge as o,Ue as p,Ke as q,Oe as r,We as s,Be as t,ie as u,q as v,Te as w,Pe as x,we as y,Le as z};
