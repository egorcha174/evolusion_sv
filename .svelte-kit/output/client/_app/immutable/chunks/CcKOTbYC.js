var m=Object.defineProperty;var p=(s,e,t)=>e in s?m(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var i=(s,e,t)=>p(s,typeof e!="symbol"?e+"":e,t);import{d as l,w}from"./C55cz5NW.js";class f{constructor(e,t){i(this,"ws",null);i(this,"url");i(this,"token");i(this,"messageId",0);i(this,"subscriptions",new Map);i(this,"pendingCommands",new Map);i(this,"stateChangeCallbacks",new Set);i(this,"reconnectAttempts",0);i(this,"maxReconnectAttempts",5);i(this,"connectPromise",null);i(this,"forcedDisconnect",!1);this.url=this.formatUrl(e),this.token=t}formatUrl(e){const n=e.startsWith("https")?"wss://":"ws://";let c=e.replace(/^https?:\/\//,"").replace(/\/$/,"");return`${n}${c}/api/websocket`}async connect(){if(this.forcedDisconnect=!1,!this.isConnected())return new Promise((e,t)=>{this.connectPromise={resolve:e,reject:t};try{this.ws=new WebSocket(this.url)}catch(n){this._onError(new Event("error")),t(n);return}this.ws.onopen=this._onOpen.bind(this),this.ws.onmessage=this._onMessage.bind(this),this.ws.onerror=this._onError.bind(this),this.ws.onclose=this._onClose.bind(this)})}async disconnect(){this.forcedDisconnect=!0,this.ws&&(this.ws.close(),this.ws=null)}isConnected(){return this.ws!==null&&this.ws.readyState===1}async getStates(){return this._sendCommand({type:"get_states"})}async subscribe(e="state_changed"){return await this._sendCommand({type:"subscribe_events",event_type:e})}unsubscribe(e){this._send({type:"unsubscribe_events",subscription:e}).catch(console.error),this.subscriptions.delete(e)}async callService(e,t,n={}){await this._sendCommand({type:"call_service",domain:e,service:t,service_data:n})}onStateChange(e){this.stateChangeCallbacks.add(e)}async _sendCommand(e){if(!this.isConnected())throw new Error("Not connected");const t=++this.messageId,n={...e,id:t};return new Promise((c,a)=>{this.pendingCommands.set(t,{resolve:c,reject:a}),this.ws.send(JSON.stringify(n)),e.type==="subscribe_events"&&this.subscriptions.set(t,d=>{(e.event_type==="state_changed"||!e.event_type)&&this.stateChangeCallbacks.forEach(u=>u(d))})})}async _send(e){if(!this.isConnected())return;const t=++this.messageId,n={...e,id:t};this.ws.send(JSON.stringify(n))}_onOpen(){console.log("WS Open")}_onMessage(e){let t;try{t=JSON.parse(e.data)}catch(n){console.error("Failed to parse WS message",n);return}switch(t.type){case"auth_required":this._sendAuth();break;case"auth_ok":this.reconnectAttempts=0,this.connectPromise&&(this.connectPromise.resolve(null),this.connectPromise=null);break;case"auth_invalid":this.connectPromise&&(this.connectPromise.reject(new Error(t.message)),this.connectPromise=null),this.disconnect();break;case"result":this._handleResult(t);break;case"event":this._handleEvent(t);break}}_sendAuth(){const e={type:"auth",access_token:this.token};this.ws.send(JSON.stringify(e))}_handleResult(e){var n;const t=this.pendingCommands.get(e.id);t&&(e.success?e.result!==void 0?t.resolve(e.result):t.resolve(e.id):t.reject(new Error(((n=e.error)==null?void 0:n.message)||"Unknown error")),this.pendingCommands.delete(e.id))}_handleEvent(e){const t=this.subscriptions.get(e.id);t&&t(e.event)}_onError(e){console.error("WS Error",e),this.connectPromise&&(this.connectPromise.reject(new Error("WebSocket connection failed")),this.connectPromise=null)}_onClose(e){console.log("WS Close",e.code,e.reason),this.connectPromise&&(this.connectPromise.reject(new Error("Connection closed during handshake")),this.connectPromise=null),this.ws=null,this.pendingCommands.forEach(t=>t.reject(new Error("Connection closed"))),this.pendingCommands.clear(),this.forcedDisconnect||this._attemptReconnect()}_attemptReconnect(){if(this.reconnectAttempts>=this.maxReconnectAttempts){console.error("Max reconnect attempts reached");return}this.reconnectAttempts++;const e=Math.min(1e3*Math.pow(2,this.reconnectAttempts),3e4);console.log(`Reconnecting in ${e}ms... (Attempt ${this.reconnectAttempts})`),setTimeout(()=>{this.connect().catch(t=>console.error("Reconnect failed",t))},e)}}const r=w({isConnected:!1,isLoading:!1,error:null,entities:new Map}),C=l(r,s=>Array.from(s.entities.values()));l(r,s=>Array.from(s.entities.values()).filter(e=>e.state!=="unavailable"));let o=null;async function S(s,e){o&&await _(),r.update(t=>({...t,isLoading:!0,error:null}));try{o=new f(s,e),await o.connect();const t=await o.getStates();r.update(n=>{const c=new Map;return t.forEach(a=>{c.set(a.entity_id,h(a))}),{...n,isConnected:!0,entities:c}}),await o.subscribe("state_changed"),o.onStateChange(n=>{n.data.new_state&&g(n.data.entity_id,h(n.data.new_state))})}catch(t){if(console.error("HA Connection failed:",t),r.update(n=>({...n,isConnected:!1,error:t.message||"Connection failed"})),o){try{await o.disconnect()}catch{}o=null}}finally{r.update(t=>({...t,isLoading:!1}))}}async function _(){o&&(await o.disconnect(),o=null),r.update(s=>({...s,isConnected:!1,entities:new Map,error:null}))}function g(s,e){r.update(t=>{const n=new Map(t.entities);return n.set(s,e),{...t,entities:n}})}function h(s){return{entity_id:s.entity_id,state:s.state,attributes:s.attributes,last_changed:s.last_changed,last_updated:s.last_updated,context:s.context}}export{_ as d,C as e,r as h,S as i};
